{"version":3,"file":"photoswipe.esm.js","sources":["../../../src/js/util/util.js","../../../src/js/util/dom-events.js","../../../src/js/util/viewport-size.js","../../../src/js/slide/pan-bounds.js","../../../src/js/slide/zoom-level.js","../../../src/js/slide/slide.js","../../../src/js/gestures/drag-handler.js","../../../src/js/gestures/zoom-handler.js","../../../src/js/gestures/tap-handler.js","../../../src/js/gestures/gestures.js","../../../src/js/main-scroll.js","../../../src/js/keyboard.js","../../../src/js/util/css-animation.js","../../../src/js/util/spring-easer.js","../../../src/js/util/spring-animation.js","../../../src/js/util/animations.js","../../../src/js/scroll-wheel.js","../../../src/js/ui/ui-element.js","../../../src/js/ui/button-arrow.js","../../../src/js/ui/button-close.js","../../../src/js/ui/button-zoom.js","../../../src/js/ui/loading-indicator.js","../../../src/js/ui/counter-indicator.js","../../../src/js/ui/ui.js","../../../src/js/slide/get-thumb-bounds.js","../../../src/js/core/eventable.js","../../../src/js/slide/placeholder.js","../../../src/js/slide/content.js","../../../src/js/core/base.js","../../../src/js/opener.js","../../../src/js/slide/loader.js","../../../src/js/photoswipe.js"],"sourcesContent":["/**\r\n  * Creates element and optionally appends it to another.\r\n  *\r\n  * @param {String} className\r\n  * @param {String|NULL} tagName\r\n  * @param {Element|NULL} appendToEl\r\n  */\r\nexport function createElement(className, tagName, appendToEl) {\r\n  const el = document.createElement(tagName || 'div');\r\n  if (className) {\r\n    el.className = className;\r\n  }\r\n  if (appendToEl) {\r\n    appendToEl.appendChild(el);\r\n  }\r\n  return el;\r\n}\r\n\r\nexport function equalizePoints(p1, p2) {\r\n  p1.x = p2.x;\r\n  p1.y = p2.y;\r\n  if (p2.id !== undefined) {\r\n    p1.id = p2.id;\r\n  }\r\n  return p1;\r\n}\r\n\r\n\r\nexport function roundPoint(p) {\r\n  p.x = Math.round(p.x);\r\n  p.y = Math.round(p.y);\r\n}\r\n\r\n/**\r\n * Returns distance between two points.\r\n *\r\n * @param {Object} p1 Point\r\n * @param {Object} p2 Point\r\n */\r\nexport function getDistanceBetween(p1, p2) {\r\n  const x = Math.abs(p1.x - p2.x);\r\n  const y = Math.abs(p1.y - p2.y);\r\n  return Math.sqrt((x * x) + (y * y));\r\n}\r\n\r\n/**\r\n * Whether X and Y positions of points are qual\r\n *\r\n * @param {Object} p1\r\n * @param {Object} p2\r\n */\r\nexport function pointsEqual(p1, p2) {\r\n  return p1.x === p2.x && p1.y === p2.y;\r\n}\r\n\r\n/**\r\n * The float result between the min and max values.\r\n *\r\n * @param {Number} val\r\n * @param {Number} min\r\n * @param {Number} max\r\n */\r\nexport function clamp(val, min, max) {\r\n  return Math.min(Math.max(val, min), max);\r\n}\r\n\r\n/**\r\n * Get transform string\r\n *\r\n * @param {Number} x\r\n * @param {Number|null} y\r\n * @param {Number|null} scale\r\n */\r\nexport function toTransformString(x, y, scale) {\r\n  let propValue = 'translate3d('\r\n    + x + 'px,' + (y || 0) + 'px'\r\n    + ',0)';\r\n\r\n  if (scale !== undefined) {\r\n    propValue += ' scale3d('\r\n      + scale + ',' + scale\r\n      + ',1)';\r\n  }\r\n\r\n  return propValue;\r\n}\r\n\r\n/**\r\n * Apply transform:translate(x, y) scale(scale) to element\r\n *\r\n * @param {DOMElement} el\r\n * @param {Number} x\r\n * @param {Number|null} y\r\n * @param {Number|null} scale\r\n */\r\nexport function setTransform(el, x, y, scale) {\r\n  el.style.transform = toTransformString(x, y, scale);\r\n}\r\n\r\nconst defaultCSSEasing = 'cubic-bezier(.4,0,.22,1)';\r\n\r\n/**\r\n * Apply CSS transition to element\r\n *\r\n * @param {Element} el\r\n * @param {String} prop CSS property to animate\r\n * @param {Number} duration in ms\r\n * @param {String|NULL} ease CSS easing function\r\n */\r\nexport function setTransitionStyle(el, prop, duration, ease) {\r\n  // inout: 'cubic-bezier(.4, 0, .22, 1)', // for \"toggle state\" transitions\r\n  // out: 'cubic-bezier(0, 0, .22, 1)', // for \"show\" transitions\r\n  // in: 'cubic-bezier(.4, 0, 1, 1)'// for \"hide\" transitions\r\n  el.style.transition = prop\r\n    ? (prop + ' ' + duration + 'ms ' + (ease || defaultcsseasing))\r\n    : 'none';\r\n}\r\n\r\n/**\r\n * apply width and height css properties to element\r\n */\r\nexport function setwidthheight(el, w, h) {\r\n  el.style.width = (typeof w === 'number') ? (w + 'px') : w;\r\n  el.style.height = (typeof h === 'number') ? (h + 'px') : h;\r\n}\r\n\r\nexport function removetransitionstyle(el) {\r\n  settransitionstyle(el);\r\n}\r\n\r\nexport function decodeimage(img) {\r\n  if ('decode' in img) {\r\n    return img.decode();\r\n  }\r\n\r\n  if (img.complete) {\r\n    return promise.resolve(img);\r\n  }\r\n\r\n  return new promise((resolve, reject) => {\r\n    img.onload = () => resolve(img);\r\n    img.onerror = reject;\r\n  });\r\n}\r\n\r\nexport const load_state = {\r\n  idle: 'idle',\r\n  loading: 'loading',\r\n  loaded: 'loaded',\r\n  error: 'error',\r\n};\r\n\r\n\r\n/**\r\n * check if click or keydown event was dispatched\r\n * with a special key or via mouse wheel.\r\n *\r\n * @param {event} e\r\n */\r\nexport function specialkeyused(e) {\r\n  if (e.which === 2 || e.ctrlkey || e.metakey || e.altkey || e.shiftkey) {\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * parse `gallery` or `children` options.\r\n *\r\n * @param {element|nodelist|string} option\r\n * @param {string|null} legacyselector\r\n * @param {element|null} parent\r\n * @returns element[]\r\n */\r\nexport function getelementsfromoption(option, legacyselector, parent = document) {\r\n  let elements = [];\r\n\r\n  if (option instanceof element) {\r\n    elements = [option];\r\n  } else if (option instanceof nodelist || array.isarray(option)) {\r\n    elements = array.from(option);\r\n  } else {\r\n    const selector = typeof option === 'string' ? option : legacyselector;\r\n    if (selector) {\r\n      elements = array.from(parent.queryselectorall(selector));\r\n    }\r\n  }\r\n\r\n  return elements;\r\n}\r\n\r\n/**\r\n * @param {*} v\r\n * @returns boolean\r\n */\r\nexport function isclass(fn) {\r\n  return typeof fn === 'function' && /^\\s*class\\s+/.test(fn.tostring());\r\n}\r\n","// detect passive event listener support\r\nlet supportspassive = false;\r\n/* eslint-disable */\r\ntry {\r\n  window.addeventlistener('test', null, object.defineproperty({}, 'passive', {\r\n    get: () => {\r\n      supportspassive = true;\r\n    }\r\n  }));\r\n} catch (e) {}\r\n/* eslint-enable */\r\n\r\nclass domevents {\r\n  constructor() {\r\n    this._pool = [];\r\n  }\r\n\r\n  /**\r\n   * adds event listeners\r\n   *\r\n   * @param {domelement} target\r\n   * @param {string} type can be multiple, separated by space.\r\n   * @param {function} listener\r\n   * @param {boolean} passive\r\n   */\r\n  add(target, type, listener, passive) {\r\n    this._togglelistener(target, type, listener, passive);\r\n  }\r\n\r\n  /**\r\n   * removes event listeners\r\n   *\r\n   * @param {domelement} target\r\n   * @param {string} type\r\n   * @param {function} listener\r\n   * @param {boolean} passive\r\n   */\r\n  remove(target, type, listener, passive) {\r\n    this._togglelistener(target, type, listener, passive, true);\r\n  }\r\n\r\n  /**\r\n   * removes all bound events\r\n   */\r\n  removeall() {\r\n    this._pool.foreach((poolitem) => {\r\n      this._togglelistener(\r\n        poolitem.target,\r\n        poolitem.type,\r\n        poolitem.listener,\r\n        poolitem.passive,\r\n        true,\r\n        true\r\n      );\r\n    });\r\n    this._pool = [];\r\n  }\r\n\r\n  /**\r\n   * adds or removes event\r\n   *\r\n   * @param {domelement} target\r\n   * @param {string} type\r\n   * @param {function} listener\r\n   * @param {boolean} passive\r\n   * @param {boolean} unbind whether the event should be added or removed\r\n   * @param {boolean} skippool whether events pool should be skipped\r\n   */\r\n  _togglelistener(target, type, listener, passive, unbind, skippool) {\r\n    if (!target) {\r\n      return;\r\n    }\r\n\r\n    const methodname = (unbind ? 'remove' : 'add') + 'eventlistener';\r\n    type = type.split(' ');\r\n    type.foreach((etype) => {\r\n      if (etype) {\r\n        // events pool is used to easily unbind all events when photoswipe is closed,\r\n        // so developer doesn't need to do this manually\r\n        if (!skippool) {\r\n          if (unbind) {\r\n            // remove from the events pool\r\n            this._pool = this._pool.filter((poolitem) => {\r\n              return poolitem.type !== etype\r\n                || poolitem.listener !== listener\r\n                || poolitem.target !== target;\r\n            });\r\n          } else {\r\n            // add to the events pool\r\n            this._pool.push({\r\n              target,\r\n              type: etype,\r\n              listener,\r\n              passive\r\n            });\r\n          }\r\n        }\r\n\r\n\r\n        // most photoswipe events call preventdefault,\r\n        // and we do not need browser to scroll the page\r\n        const eventoptions = supportspassive ? { passive: (passive || false) } : false;\r\n\r\n        target[methodname](\r\n          etype,\r\n          listener,\r\n          eventoptions\r\n        );\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default domevents;\r\n","export function getviewportsize(options, pswp) {\r\n  if (options.getviewportsizefn) {\r\n    const newviewportsize = options.getviewportsizefn(options, pswp);\r\n    if (newviewportsize) {\r\n      return newviewportsize;\r\n    }\r\n  }\r\n\r\n  return {\r\n    x: document.documentelement.clientwidth,\r\n\r\n    // todo: height on mobile is very incosistent due to toolbar\r\n    // find a way to improve this\r\n    //\r\n    // document.documentelement.clientheight - doesn't seem to work well\r\n    y: window.innerheight\r\n  };\r\n}\r\n\r\n/**\r\n * parses padding option.\r\n * supported formats:\r\n *\r\n * // object\r\n * padding: {\r\n *  top: 0,\r\n *  bottom: 0,\r\n *  left: 0,\r\n *  right: 0\r\n * }\r\n *\r\n * // a function that returns the object\r\n * paddingfn: (viewportsize, itemdata, index) => {\r\n *  return {\r\n *    top: 0,\r\n *    bottom: 0,\r\n *    left: 0,\r\n *    right: 0\r\n *  };\r\n * }\r\n *\r\n * // legacy variant\r\n * paddingleft: 0,\r\n * paddingright: 0,\r\n * paddingtop: 0,\r\n * paddingbottom: 0,\r\n *\r\n * @param {string}  prop 'left', 'top', 'bottom', 'right'\r\n * @param {object}  options photoswipe options\r\n * @param {object}  viewportsize photoswipe viewport size, for example: { x:800, y:600 }\r\n * @param {object}  itemdata data about the slide\r\n * @param {integer} index slide index\r\n * @returns {number}\r\n */\r\nexport function parsepaddingoption(prop, options, viewportsize, itemdata, index) {\r\n  let paddingvalue;\r\n\r\n  if (options.paddingfn) {\r\n    paddingvalue = options.paddingfn(viewportsize, itemdata, index)[prop];\r\n  } else if (options.padding) {\r\n    paddingvalue = options.padding[prop];\r\n  } else {\r\n    const legacypropname = 'padding' + prop[0].touppercase() + prop.slice(1);\r\n    if (options[legacypropname]) {\r\n      paddingvalue = options[legacypropname];\r\n    }\r\n  }\r\n\r\n  return paddingvalue || 0;\r\n}\r\n\r\n\r\nexport function getpanareasize(options, viewportsize, itemdata, index) {\r\n  return {\r\n    x: viewportsize.x\r\n      - parsepaddingoption('left', options, viewportsize, itemdata, index)\r\n      - parsepaddingoption('right', options, viewportsize, itemdata, index),\r\n    y: viewportsize.y\r\n      - parsepaddingoption('top', options, viewportsize, itemdata, index)\r\n      - parsepaddingoption('bottom', options, viewportsize, itemdata, index)\r\n  };\r\n}\r\n","/**\r\n * calculates minimum, maximum and initial (center) bounds of a slide\r\n */\r\nimport {\r\n  clamp\r\n} from '../util/util.js';\r\nimport { parsepaddingoption } from '../util/viewport-size.js';\r\n\r\nclass panbounds {\r\n  constructor(slide) {\r\n    this.slide = slide;\r\n\r\n    this.currzoomlevel = 1;\r\n\r\n    this.center = {};\r\n    this.max = {};\r\n    this.min = {};\r\n\r\n    this.reset();\r\n  }\r\n\r\n  // _getitembounds\r\n  update(currzoomlevel) {\r\n    this.currzoomlevel = currzoomlevel;\r\n\r\n    if (!this.slide.width) {\r\n      this.reset();\r\n    } else {\r\n      this._updateaxis('x');\r\n      this._updateaxis('y');\r\n      this.slide.pswp.dispatch('calcbounds', { slide: this.slide });\r\n    }\r\n  }\r\n\r\n  // _calculateitemboundsforaxis\r\n  _updateaxis(axis) {\r\n    const { pswp } = this.slide;\r\n    const elsize = this.slide[axis === 'x' ? 'width' : 'height'] * this.currzoomlevel;\r\n    const paddingprop = axis === 'x' ? 'left' : 'top';\r\n    const padding = parsepaddingoption(\r\n      paddingprop,\r\n      pswp.options,\r\n      pswp.viewportsize,\r\n      this.slide.data,\r\n      this.slide.index\r\n    );\r\n\r\n    const panareasize = this.slide.panareasize[axis];\r\n\r\n    // default position of element.\r\n    // by defaul it is center of viewport:\r\n    this.center[axis] = math.round((panareasize - elsize) / 2) + padding;\r\n\r\n    // maximum pan position\r\n    this.max[axis] = (elsize > panareasize)\r\n      ? math.round(panareasize - elsize) + padding\r\n      : this.center[axis];\r\n\r\n    // minimum pan position\r\n    this.min[axis] = (elsize > panareasize)\r\n      ? padding\r\n      : this.center[axis];\r\n  }\r\n\r\n  // _getzerobounds\r\n  reset() {\r\n    this.center.x = 0;\r\n    this.center.y = 0;\r\n    this.max.x = 0;\r\n    this.max.y = 0;\r\n    this.min.x = 0;\r\n    this.min.y = 0;\r\n  }\r\n\r\n  /**\r\n   * correct pan position if it's beyond the bounds\r\n   *\r\n   * @param {string} axis x or y\r\n   * @param {object} panoffset\r\n   */\r\n  correctpan(axis, panoffset) { // checkpanbounds\r\n    ret