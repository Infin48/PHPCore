{"version":3,"file":"photoswipe-lightbox.esm.js","sources":["../../../src/js/util/util.js","../../../src/js/core/eventable.js","../../../src/js/slide/placeholder.js","../../../src/js/slide/content.js","../../../src/js/core/base.js","../../../src/js/util/viewport-size.js","../../../src/js/slide/zoom-level.js","../../../src/js/slide/loader.js","../../../src/js/lightbox/lightbox.js"],"sourcesContent":["/**\r\n  * Creates element and optionally appends it to another.\r\n  *\r\n  * @param {String} className\r\n  * @param {String|NULL} tagName\r\n  * @param {Element|NULL} appendToEl\r\n  */\r\nexport function createElement(className, tagName, appendToEl) {\r\n  const el = document.createElement(tagName || 'div');\r\n  if (className) {\r\n    el.className = className;\r\n  }\r\n  if (appendToEl) {\r\n    appendToEl.appendChild(el);\r\n  }\r\n  return el;\r\n}\r\n\r\nexport function equalizePoints(p1, p2) {\r\n  p1.x = p2.x;\r\n  p1.y = p2.y;\r\n  if (p2.id !== undefined) {\r\n    p1.id = p2.id;\r\n  }\r\n  return p1;\r\n}\r\n\r\n\r\nexport function roundPoint(p) {\r\n  p.x = Math.round(p.x);\r\n  p.y = Math.round(p.y);\r\n}\r\n\r\n/**\r\n * Returns distance between two points.\r\n *\r\n * @param {Object} p1 Point\r\n * @param {Object} p2 Point\r\n */\r\nexport function getDistanceBetween(p1, p2) {\r\n  const x = Math.abs(p1.x - p2.x);\r\n  const y = Math.abs(p1.y - p2.y);\r\n  return Math.sqrt((x * x) + (y * y));\r\n}\r\n\r\n/**\r\n * Whether X and Y positions of points are qual\r\n *\r\n * @param {Object} p1\r\n * @param {Object} p2\r\n */\r\nexport function pointsEqual(p1, p2) {\r\n  return p1.x === p2.x && p1.y === p2.y;\r\n}\r\n\r\n/**\r\n * The float result between the min and max values.\r\n *\r\n * @param {Number} val\r\n * @param {Number} min\r\n * @param {Number} max\r\n */\r\nexport function clamp(val, min, max) {\r\n  return Math.min(Math.max(val, min), max);\r\n}\r\n\r\n/**\r\n * Get transform string\r\n *\r\n * @param {Number} x\r\n * @param {Number|null} y\r\n * @param {Number|null} scale\r\n */\r\nexport function toTransformString(x, y, scale) {\r\n  let propValue = 'translate3d('\r\n    + x + 'px,' + (y || 0) + 'px'\r\n    + ',0)';\r\n\r\n  if (scale !== undefined) {\r\n    propValue += ' scale3d('\r\n      + scale + ',' + scale\r\n      + ',1)';\r\n  }\r\n\r\n  return propValue;\r\n}\r\n\r\n/**\r\n * Apply transform:translate(x, y) scale(scale) to element\r\n *\r\n * @param {DOMElement} el\r\n * @param {Number} x\r\n * @param {Number|null} y\r\n * @param {Number|null} scale\r\n */\r\nexport function setTransform(el, x, y, scale) {\r\n  el.style.transform = toTransformString(x, y, scale);\r\n}\r\n\r\nconst defaultCSSEasing = 'cubic-bezier(.4,0,.22,1)';\r\n\r\n/**\r\n * Apply CSS transition to element\r\n *\r\n * @param {Element} el\r\n * @param {String} prop CSS property to animate\r\n * @param {Number} duration in ms\r\n * @param {String|NULL} ease CSS easing function\r\n */\r\nexport function setTransitionStyle(el, prop, duration, ease) {\r\n  // inout: 'cubic-bezier(.4, 0, .22, 1)', // for \"toggle state\" transitions\r\n  // out: 'cubic-bezier(0, 0, .22, 1)', // for \"show\" transitions\r\n  // in: 'cubic-bezier(.4, 0, 1, 1)'// for \"hide\" transitions\r\n  el.style.transition = prop\r\n    ? (prop + ' ' + duration + 'ms ' + (ease || defaultcsseasing))\r\n    : 'none';\r\n}\r\n\r\n/**\r\n * apply width and height css properties to element\r\n */\r\nexport function setwidthheight(el, w, h) {\r\n  el.style.width = (typeof w === 'number') ? (w + 'px') : w;\r\n  el.style.height = (typeof h === 'number') ? (h + 'px') : h;\r\n}\r\n\r\nexport function removetransitionstyle(el) {\r\n  settransitionstyle(el);\r\n}\r\n\r\nexport function decodeimage(img) {\r\n  if ('decode' in img) {\r\n    return img.decode();\r\n  }\r\n\r\n  if (img.complete) {\r\n    return promise.resolve(img);\r\n  }\r\n\r\n  return new promise((resolve, reject) => {\r\n    img.onload = () => resolve(img);\r\n    img.onerror = reject;\r\n  });\r\n}\r\n\r\nexport const load_state = {\r\n  idle: 'idle',\r\n  loading: 'loading',\r\n  loaded: 'loaded',\r\n  error: 'error',\r\n};\r\n\r\n\r\n/**\r\n * check if click or keydown event was dispatched\r\n * with a special key or via mouse wheel.\r\n *\r\n * @param {event} e\r\n */\r\nexport function specialkeyused(e) {\r\n  if (e.which === 2 || e.ctrlkey || e.metakey || e.altkey || e.shiftkey) {\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * parse `gallery` or `children` options.\r\n *\r\n * @param {element|nodelist|string} option\r\n * @param {string|null} legacyselector\r\n * @param {element|null} parent\r\n * @returns element[]\r\n */\r\nexport function getelementsfromoption(option, legacyselector, parent = document) {\r\n  let elements = [];\r\n\r\n  if (option instanceof element) {\r\n    elements = [option];\r\n  } else if (option instanceof nodelist || array.isarray(option)) {\r\n    elements = array.from(option);\r\n  } else {\r\n    const selector = typeof option === 'string' ? option : legacyselector;\r\n    if (selector) {\r\n      elements = array.from(parent.queryselectorall(selector));\r\n    }\r\n  }\r\n\r\n  return elements;\r\n}\r\n\r\n/**\r\n * @param {*} v\r\n * @returns boolean\r\n */\r\nexport function isclass(fn) {\r\n  return typeof fn === 'function' && /^\\s*class\\s+/.test(fn.tostring());\r\n}\r\n","/**\r\n * base photoswipe event object\r\n */\r\nclass photoswipeevent {\r\n  constructor(type, details) {\r\n    this.type = type;\r\n    if (details) {\r\n      object.assign(this, details);\r\n    }\r\n  }\r\n\r\n  preventdefault() {\r\n    this.defaultprevented = true;\r\n  }\r\n}\r\n\r\n/**\r\n * photoswipe base class that can listen and dispatch for events.\r\n * shared by photoswipe core and photoswipe lightbox, extended by base.js\r\n */\r\nclass eventable {\r\n  constructor() {\r\n    this._listeners = {};\r\n    this._filters = {};\r\n  }\r\n\r\n  addfilter(name, fn, priority = 100) {\r\n    if (!this._filters[name]) {\r\n      this._filters[name] = [];\r\n    }\r\n\r\n    this._filters[name].push({ fn, priority });\r\n    this._filters[name].sort((f1, f2) => f1.priority - f2.priority);\r\n\r\n    if (this.pswp) {\r\n      this.pswp.addfilter(name, fn, priority);\r\n    }\r\n  }\r\n\r\n  removefilter(name, fn) {\r\n    if (this._filters[name]) {\r\n      this._filters[name] = this._filters[name].filter(filter => (filter.fn !== fn));\r\n    }\r\n\r\n    if (this.pswp) {\r\n      this.pswp.removefilter(name, fn);\r\n    }\r\n  }\r\n\r\n  applyfilters(name, ...args) {\r\n    if (this._filters[name]) {\r\n      this._filters[name].foreach((filter) => {\r\n        args[0] = filter.fn.apply(this, args);\r\n      });\r\n    }\r\n    return args[0];\r\n  }\r\n\r\n  on(name, fn) {\r\n    if (!this._listeners[name]) {\r\n      this._listeners[name] = [];\r\n    }\r\n    this._listeners[name].push(fn);\r\n\r\n    // when binding events to lightbox,\r\n    // also bind events to photoswipe core,\r\n    // if it's open.\r\n    if (this.pswp) {\r\n      this.pswp.on(name, fn);\r\n    }\r\n  }\r\n\r\n  off(name, fn) {\r\n    if (this._listeners[name]) {\r\n      this._listeners[name] = this._listeners[name].filter(listener => (fn !== listener));\r\n    }\r\n\r\n    if (this.pswp) {\r\n      this.pswp.off(name, fn);\r\n    }\r\n  }\r\n\r\n  dispatch(name, details) {\r\n    if (this.pswp) {\r\n      return this.pswp.dispatch(name, details);\r\n    }\r\n\r\n    const event = new photoswipeevent(name, details);\r\n\r\n    if (!this._listeners) {\r\n      return event;\r\n    }\r\n\r\n    if (this._listeners[name]) {\r\n      this._listeners[name].foreach((listener) => {\r\n        listener.call(this, event);\r\n      });\r\n    }\r\n\r\n    return event;\r\n  }\r\n}\r\n\r\nexport default eventable;\r\n","import { createelement, setwidthheight, totransformstring } from '../util/util.js';\r\n\r\nclass placeholder {\r\n  /**\r\n   * @param {string|false} imagesrc\r\n   * @param {element} container\r\n   */\r\n  constructor(imagesrc, container) {\r\n    // create placeholder\r\n    // (stretched thumbnail or simple div behind the main image)\r\n    this.element = createelement(\r\n      'pswp__img pswp__img--placeholder',\r\n      imagesrc ? 'img' : '',\r\n      container\r\n    );\r\n\r\n    if (imagesrc) {\r\n      this.element.decoding = 'async';\r\n      this.element.alt = '';\r\n      this.element.src = imagesrc;\r\n      this.element.setattribute('role', 'presentation');\r\n    }\r\n\r\n    this.element.setattribute('aria-hiden', 'true');\r\n  }\r\n\r\n  setdisplayedsize(width, height) {\r\n    if (!this.element) {\r\n      return;\r\n    }\r\n\r\n    if (this.element.tagname === 'img') {\r\n      // use transform scale() to modify img placeholder size\r\n      // (instead of changing width/height directly).\r\n      // this helps with performance, specifically in ios15 safari.\r\n      setwidthheight(this.element, 250, 'auto');\r\n      this.element.style.transformorigin = '0 0';\r\n      this.element.style.transform = totransformstring(0, 0, width / 250);\r\n    } else {\r\n      setwidthheight(this.element, width, height);\r\n    }\r\n  }\r\n\r\n  destroy() {\r\n    if (this.element.parentnode) {\r\n      this.element.remove();\r\n    }\r\n    this.element = null;\r\n  }\r\n}\r\n\r\nexport default placeholder;\r\n","import { createelement, load_state, setwidthheight } from '../util/util.js';\r\nimport placeholder from './placeholder.js';\r\n\r\nclass content {\r\n  /**\r\n   * @param {object} itemdata slide data\r\n   * @param {photoswipebase} instance photoswipe or photoswipelightbox instance\r\n   * @param {slide|undefined} slide slide that requested the image,\r\n   *                                can be undefined if image was requested by something else\r\n   *                                (for example by lazy-loader)\r\n   */\r\n  constructor(itemdata, instance, index) {\r\n    this.instance = instance;\r\n    this.data = itemdata;\r\n    this.index = index;\r\n\r\n    this.width = number(this.data.w) || number(this.data.width) || 0;\r\n    this.height = number(this.data.h) || number(this.data.height) || 0;\r\n\r\n    this.isattached = false;\r\n    this.hasslide = false;\r\n    this.state = load_state.idle;\r\n\r\n    if (this.data.type) {\r\n      this.type = this.data.type;\r\n    } else if (this.data.src) {\r\n      this.type = 'image';\r\n    } else {\r\n      this.type = 'html';\r\n    }\r\n\r\n    this.instance.dispatch('contentinit', { content: this });\r\n  }\r\n\r\n  removeplaceholder() {\r\n    if (this.placeholder && !this.keepplaceholder()) {\r\n      // with delay, as image might be loaded, but not rendered\r\n      settimeout(() => {\r\n        if (this.placeholder) {\r\n          this.placeholder.destroy();\r\n          this.placeholder = null;\r\n        }\r\n      }, 500);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * preload content\r\n   *\r\n   * @param {boolean} islazy\r\n   */\r\n  load(islazy, reload) {\r\n    if (!this.placeholder && this.slide && this.useplaceholder()) {\r\n      // use   -based placeholder only for the first slide,\r\n      // as rendering (even small stretched thumbnail) is an expensive operation\r\n      const placeholdersrc = this.instance.applyfilters(\r\n        'placeholdersrc',\r\n        (this.data.msrc && this.slide.isfirstslide) ? this.data.msrc : false,\r\n        this\r\n      );\r\n      this.placeholder = new placeholder(\r\n        placeholdersrc,\r\n        this.slide.container\r\n      );\r\n    }\r\n\r\n    if (this.element && !reload) {\r\n      return;\r\n    }\r\n\r\n    if (this.instance.dispatch('contentload', { content: this, islazy }).defaultprevented) {\r\n      return;\r\n    }\r\n\r\n    if (this.isimagecontent()) {\r\n      this.loadimage(islazy);\r\n    } else {\r\n      this.element = createelement('pswp__content');\r\n      this.element.innerhtml = this.data.html || '';\r\n    }\r\n\r\n    if (reload && this.slide) {\r\n      this.slide.updatecontentsize(true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * preload image\r\n   *\r\n   * @param {boolean} islazy\r\n   */\r\n  loadimage(islazy) {\r\n    this.element = createelement('pswp__img', 'img');\r\n\r\n    if (this.instance.dispatch('contentloadimage', { content: this, islazy }).defaultprevented) {\r\n      return;\r\n    }\r\n\r\n    if (this.data.srcset) {\r\n      this.element.srcset = this.data.srcset;\r\n    }\r\n\r\n    this.element.src = this.data.src;\r\n\r\n    this.element.alt = this.data.alt || '';\r\n\r\n    this.state = load_state.loading;\r\n\r\n    if (this.element.complete) {\r\n      this.onloaded();\r\n    } else {\r\n      this.element.onload = () => {\r\n        this.onloaded();\r\n      };\r\n\r\n      this.element.onerror = () => {\r\n        this.onerror();\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * assign slide to content\r\n   *\r\n   * @param {slide} slide\r\n   */\r\n  setslide(slide) {\r\n    this.slide = slide;\r\n    this.hasslide = true;\r\n    this.instance = slide.pswp;\